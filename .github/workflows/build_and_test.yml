
name: Build_And_Test

on:
  push:
    branches:
    - 'main'

  workflow_dispatch:

env:
  SPAWNDATAIMAGE: "mssql-empty:v2019"
  TARGETDATABASE: "tSQLtVSCTemplate"
  # If this SQLPACKAGEPATH starts failing, use the "Find SqlPackage.exe" workflow to find the new path.
  SQLPACKAGEPATH: "C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\Common7\\IDE\\Extensions\\Microsoft\\SQLDB\\DAC\\SqlPackage.exe"

  DACPACS_PATH: ./dacpac_output  
  DACPAC_FILES: 'Demo.dacpac, tSQLt.2019.dacpac, Tests.dacpac' #In deployment order


jobs:

  build:
    name: Build Database Project
    runs-on: windows-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup MSBuild path
      uses: microsoft/setup-msbuild@v1.1

    - name: Build .sqlproj
      run: msbuild ./Tests/Tests.sqlproj /p:Configuration=Release /p:OutDir=../output/

    - name: Upload DACPAC as Artifact
      uses: actions/upload-artifact@v3
      with:
        name: dacpac
        path: ./output/*.dacpac

  checkartifact:
    name: Inspect Artifact
    needs: [build]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Download DACPAC Artifact
      uses: actions/download-artifact@v3
      with:
        name: dacpac
        path: $env:DACPACS_PATH

    - name: List File In Artifact
      run: |
        cd $env:DACPACS_PATH
        ls -laR
      
  create_ci_mssql_instance:
    name: Create CI MSSQL Instance
    runs-on: ubuntu-latest
    
    steps:
    - name: Create Data Container
      id: create-container
      uses: red-gate/create-spawn-data-container/@v1.1
      with:
        dataImage: ${{ env.SPAWNDATAIMAGE }}
        lifetime: '15m'
        useMasking: 'false'
      env:
        SPAWNCTL_ACCESS_TOKEN: ${{ secrets.SPAWNCTL_ACCESS_TOKEN }}

    - name: Create Container Variables
      id: create-container-vars
      shell: pwsh
      run: |
        $containerFQDN =$env:containerHost+", "+$env:containerPort;
        $containerUser = $env:containerUsername;
        $containerPassword = $env:containerPassword;

        Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
        Write-Host "Container Name: "$env:containerName;
        Write-Host "Container FQDN: "$containerFQDN;
        Write-Host "Container Username: "$containerUser;
        Write-Host "Container Password: "$containerPassword;
        Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";

        Write-Host ('::set-output name=containerFQDN::'+$containerFQDN);
      env:
        containerName: ${{ steps.create-container.outputs.dataContainerName }}
        containerHost: ${{ steps.create-container.outputs.dataContainerHost }}
        containerPort: ${{ steps.create-container.outputs.dataContainerPort }}
        containerUsername: ${{ steps.create-container.outputs.dataContainerUsername }}
        containerPassword: ${{ steps.create-container.outputs.dataContainerPassword }}
    outputs:
      containerFQDN: ${{ steps.create-container-vars.outputs.containerFQDN }}
      containerUser: ${{ steps.create-container.outputs.dataContainerUsername }}
      containerPassword: ${{ steps.create-container.outputs.dataContainerPassword }} 


  deploy:
    name: Deploy Database Project
    needs: [build, create_ci_mssql_instance]
    runs-on: windows-latest

    env:
      containerFQDN: ${{ needs.create_ci_mssql_instance.outputs.containerFQDN }}
      containerUser: ${{ needs.create_ci_mssql_instance.outputs.containerUser }}
      containerPassword: ${{ needs.create_ci_mssql_instance.outputs.containerPassword }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Download DACPAC Artifact
      uses: actions/download-artifact@v3
      with:
        name: dacpac
        path: $env:DACPACS_PATH

    - name: Prepare SQL Server Instance
      shell: pwsh
      run: |

        Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
        Write-Host "";

        $DS = Invoke-Sqlcmd -ConnectionTimeout 600 -Query "SELECT SUSER_NAME() U,SYSDATETIME() T,@@VERSION V;" -ServerInstance $env:containerFQDN -Username $env:containerUser -Password $env:containerPassword -As DataSet
        $DS.Tables[0].Rows | %{ echo "{ $($_['U']), $($_['T']), $($_['V']) }" };

        Write-Host "";
        Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";

        Invoke-Sqlcmd -InputFile "./tSQLt/PrepareServer.sql" -ServerInstance $env:containerFQDN -Username $env:containerUser -Password $env:containerPassword

        $targetConnectionString="Data Source="+$env:containerFQDN+";User ID="+$env:containerUser+";Password="+$env:containerPassword+";Pooling=False;Integrated Security=false;Initial Catalog=tempdb;";
        echo "target_connection_string=$targetConnectionString" | Out-File -Append -FilePath $env:GITHUB_ENV

    - name: Check vars
      shell: pwsh
      run: |

        Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
        Write-Host "target_connection_string = $env:target_connection_string";
        Write-Host "✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ✨   ";
        
    - name: Deploy DACPACs
      shell: pwsh
      run: |
        $dacpacFiles = $env:DACPAC_FILES -split "," | ForEach-Object { $_.Trim() }

        for ($dacpacFile in $dacpacFiles) {
          $dacpacPath = Join-Path $env:DACPACS_PATH $dacpacFile
          $databaseName = $env:TARGETDATABASE

          # Call SqlPackage to deploy the .dacpac
          & "$env:SQLPACKAGEPATH" /Action:Publish /TargetConnectionString:"$env:CONNECTION_STRING" /TargetDatabaseName:"$databaseName" /SourceFile:"$dacpacPath"

          # Check if SqlPackage was successful
          if ($LASTEXITCODE -ne 0) {
              Write-Error "Deployment failed for $dacpacFile in $databaseName"
              # Exit the script on failure
              exit $LASTEXITCODE
          } else {
              Write-Host "Deployment succeeded for $dacpacFile in $databaseName"
          }
        }
        
  validate:
    name: Validate Database Solution
    needs: [deploy, create_ci_mssql_instance]
    runs-on: windows-latest

    env:
      containerFQDN: ${{ needs.create_ci_mssql_instance.outputs.containerFQDN }}
      containerUser: ${{ needs.create_ci_mssql_instance.outputs.containerUser }}
      containerPassword: ${{ needs.create_ci_mssql_instance.outputs.containerPassword }}

    steps:
    - name: Run Tests
      shell: pwsh
      run: |
        $query = "EXEC tSQLt.SetSummaryError @SummaryError=0;EXEC tSQLt.SetVerbose @Verbose = 1;EXEC tSQLt.RunAll;";

        Invoke-Sqlcmd -Query $query `
                      -ServerInstance $env:containerFQDN -Database $env:targetDatabase `
                      -Username $env:containerUser -Password $env:containerPassword `
                      -OutputSqlErrors $true -AbortOnError -verbose;

        $dataSet = Invoke-Sqlcmd -Query "EXEC tSQLt.XMLResultFormatter;" `
                            -ServerInstance $env:containerFQDN -Database $env:targetDatabase `
                            -Username $env:containerUser -Password $env:containerPassword `
                            -As DataSet -OutputSqlErrors $true -AbortOnError -verbose

        New-Item -Path "." -Name "TestResults" -ItemType "directory"
        $dataSet.Tables[0].Item(0)|Out-File "./TestResults/TestResults.xml";                

    - name: Upload Test Results Artifact
      uses: actions/upload-artifact@v2
      with:
        if-no-files-found: error
        name: TestResults
        path: ".\\TestResults\\"
        retention-days: 90

    - name: Check for Failures
      shell: pwsh
      run: |
        $query = "EXEC tSQLt.SetSummaryError @SummaryError=1;EXEC tSQLt.DefaultResultFormatter;";

        Invoke-Sqlcmd -Query $query `
                      -ServerInstance $env:containerFQDN -Database $env:targetDatabase `
                      -Username $env:containerUser -Password $env:containerPassword `
                      -OutputSqlErrors $true -AbortOnError -verbose;

          
